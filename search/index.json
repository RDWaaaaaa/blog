[{"content":" 没有输入输出 调试后提交，输出没有注释掉 变量重名 没开long long double有时候需要改成long double，long double输出时为%Lf 有多个测试点时，数组等要初始化，队列等要清空 1\u0026lt;\u0026lt;k只能是int型，必要时应写或者1ll\u0026lt;\u0026lt;k 符号优先级，if(((i\u0026gt;\u0026gt;j)\u0026amp;1)==0)正确,if((i\u0026gt;\u0026gt;j)\u0026amp;1==0)错误 矩形的n和m都写成n 有图的题注意重边和自环 数据并未按照顺序给出 …… ","date":"2023-10-15T23:55:09+08:00","permalink":"https://blog.nrevery.cn/p/%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%A4%AA%E8%81%AA%E6%98%8E%E7%9A%84bugs/","title":"那些不太聪明的Bugs"},{"content":"搜索 双向BFS 基本形式\nint bfs() { if (A == B) return 0; queue\u0026lt;string\u0026gt; qa, qb; unordered_map\u0026lt;string, int\u0026gt; da, db; qa.push(A), qb.push(B); da[A] = db[B] = 0;//init int step = 0; while (qa.size() \u0026amp;\u0026amp; qb.size()) { int t; if (qa.size() \u0026lt; qb.size()) t = extend(qa, da, db, a, b); else t = extend(qb, db, da, b, a); if (t \u0026lt;= 10) return t; if ( ++ step == 10) return -1; } return -1; } int extend(queue\u0026lt;string\u0026gt;\u0026amp; q, unordered_map\u0026lt;string, int\u0026gt;\u0026amp;da, unordered_map\u0026lt;string, int\u0026gt;\u0026amp; db, string a[N], string b[N]){ ... } A* 条件：边权非负，且保证有解（若无解则效率低于普通bfs）\n适用范围：求最短路等，状态很多例如八数码问题。只能保证终点第一次出队时是最小值，不能保证其他点第一次出队是最小值。\n估计距离的条件：设当前点到终点的估计距离为f(state),当前点到终点的真实子u段距离为g(state),要有f(state)\u0026lt;=g(state)\n八数码：有解充要条件是逆序对数量为偶数，估计距离为现在这个状态每个点到目标位置的曼哈顿距离之和。\n第k短路：先Dijkstra，得到每个点到终点的最短距离，以g(state)为f(state)，再A*，当终点第k次出队，就是答案。\n基本形式：\npriority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt; \u0026gt;q; q里面存：起点到当前点的准确距离（不一定最短）+当前点到终点的估计距离 while(!q.empty()){ t=q.top(); 终点第一次出队时是最小值。 q.pop(); for(t的所有邻边){ 如果能被更新就入队 } } 形式与Dijkstra相似，Dijkstra算法可看作把估计距离都取0的A*\n剪枝 优化搜索顺序\n例：小猫重量w[i],缆车最大承重W,问至少需要多少缆车。显然重量大的小猫安排较为“困难”，可以将小猫重量降序sort。\n排除等效冗余 组合问题不要写成排列\n可行性剪枝\n最优性剪枝\n记忆化搜索（dp）\n迭代加深 “找到最短的序列”类似问题 核心思想：\nwhile (!dfs(1, k))k++; 双向DFS n个物品每个重量g[i]，拿的总重不超过W，n\u0026lt;=46,W\u0026lt;=1\u0026laquo;31,求最大能拿多重。 先降序排序，前一半dfs暴搜求所有可能的总重量，降重、排序，后一半也暴搜，对后一半可能的总和x，再前一半找y\u0026lt;=W-x的最大y值，更新x+y的最大值。复杂度从 $O(2^n)$ 降到$O(log(2^{n \\over 2})*2^{n \\over 2})$即$O(n2^{n \\over 2} )$\nIDA* 例题\n给定n本书，编号为1∼n在初始状态下，书是任意排列的。 在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。 我们的目标状态是把书按照 1∼n的顺序依次排列。 求最少需要多少次操作。 若大于等于5次就直接输出\u0026quot;5 or more\u0026quot; 1\u0026lt;=n\u0026lt;=15\n思路\n先考虑每一步的决策数量： 当抽取长度为i的一段时，有n−i+1种抽法，对于每种抽法，有n−i种放法。另外，将某一段向前移动，等价于将跳过的那段向后移动，因此每种移动方式被算了两遍，所以每个状态总共的分支数量是：∑ni=1(n−i)∗(n−i+1)/2=(15∗14+14∗13+…+2∗1)/2=560\n考虑在四步以内解决，最多有 560^4个状态，会超时。可以使用双向BFS或者IDA*来优化。我们用IDA*来解决此题。\n估价函数：\n需要满足：不大于实际步数 在最终状态下，每本书后面的书的编号应该比当前书多1。 每次移动最多会断开三个相连的位置，再重新加入三个相连的位置，因此最多会将3个错误的连接修正，所以如果当前有 tot个连接，那么最少需要 ⌈tot/3⌉次操作。因此当前状态 s的估价函数可以设计成 f(s)=⌈tot/3⌉如果当前层数加上 f(s)大于迭代加深的层数上限，则直接从当前分支回溯。\n时间复杂度\n理论上最多搜索 560^4个状态，使用IDA*后实际搜索的状态数量很少。\n","date":"2023-10-15T10:36:36+08:00","permalink":"https://blog.nrevery.cn/p/acwing%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%90%9C%E7%B4%A2/","title":"AcWing学习记录-搜索"},{"content":"CTF战队招新赛 Misc Signin 略\nbase64? 题目 我的密文: ox6qJI1Q7kJY1OvuR/1CBs1yRVvuEIfeR/lCUMAGrV8LwEL= 泄露的明文: jRQfVJMwco53YF33SYjeif4oi0mGscBFhRH70i17E8IgGAVXtZGDhSK9vPkH5MhI 泄露的密文: N+d9r+rjVElQoG1krPlQ1+MG8LvXNV1p658u6L+d1L5aVsFKrEA+NEUhB/dYRTfIr/r+rxAx7suMTE+xJPrvVErqoG6r9QRGB5+0rP+s6XSWRX5/JI6m9spTTxJYNVnk9VpdrLlA1+pLPMlnNv6zbErUNLF5VPpd 你现在知道我的明文了吗？ 题解 将泄露的明文用base64加密 alJRZlZKTXdjbzV3ZWdjVlkzY0FGaTVhN1Y5N0lJV01nTmgvZXBlaXQ4UHJwMSt2ZHZlZDBDem5kSXlDcWZFTXZobzNZRjMzU1lqZWlmNG9pMG1Hc2NCRmhSSDcwaTE3RThJZ0dBVlh0WkdEaFNLOXZQa0g1TWhJ 发现泄露的密文与加密后的密文的字符有对应关系 （代码不小心删了，就是找到目前能对应的字符并且把我的密文尽量转换，并且输出目前还没有对应的字符） 将得到的不完整的明文每四个字符进行base64解密，得到flag的大部分。根据推理和几次尝试就得到完整的flag（ Robot36 题目 给了一个png文件和一个flac文件\n题解 用winhex打开cover.png，最下面有提示 用winhex打开flac文件找到wav的文件头并删除之前的内容,并转换为wav文件 用安卓手机下载Robot36，用另一个设备播放即可得到慢扫描图像 Crypto factor 题目 from Crypto.Util.number import * flag = b\u0026#39;*****\u0026#39; p = getPrime(512) q = getPrime(512) n = p*q e = 0x10001 m = bytes_to_long(flag) c = pow(m,e,n) # print(p) # print(q) print(n) print(c) #n = 155973472877500551696404049342507495077134952416313340244284845928778400385389548636037403472336378336490931666382159990607516752340206514340009510417187026921007116552045963973163720919596636575029141772459275706505175142195195686881713118383919643653234410908740422880120161538592336383479253864155940629093 #c = 32349988441710439726991823014652327949110727303493414402820119679942533399117470462729126720315109509283386087378965374529410971247867614623318967344071216979994926505735379297102144644819487720051553195643392945426400493308569024431403247836671630208580022421678378308476007451938426212992790979191141986943 题解 这是已知n、c的rsa加密题\nRSA加密算法用到六个数字，p,q,n,φ(n),e,d,主要过程如下：\n随意选择两个大的质数p和q，p不等于q，计算n=pq。 根据欧拉函数，不大于N且与N互质的整数個数為φ(n)=(p-1)(q-1)。 选择一个整数e与φ(n)互质，并且e小于φ(n)。 用以下这个公式计算d：d×e ≡ 1 (mod φ(n))。 将p和q的记录销毁。 具体过程：\n在RSATool中把n填入对应位置点Factor N,将n分解为两个素数，即p,q。 再点Calc.D得到d,此时可以点Test，输入一个数字，先加密再解密，若数字不变则测试成功，把密文c输入并解密即可得到flag 以上所有操作都可以在python中解决，且题型可以是知道6个数字中的其他一些数字，根据情况处理即可。 Web phpplayer 题目 \u0026lt;?php highlight_file(__FILE__); $flag=file_get_contents(\u0026#34;/flag\u0026#34;); $fake_flag=\u0026#34;flag{xxxxxxxxxxxxxxxxx}\u0026#34;; if(!isset($_GET[\u0026#39;a\u0026#39;])){ die(\u0026#34;error1\u0026#34;); } $num = $_GET[\u0026#39;a\u0026#39;]; if(preg_match(\u0026#34;/[0-9]/\u0026#34;, $num)){ die(\u0026#34;error1\u0026#34;); } if(!intval($num)){ die(\u0026#34;error1\u0026#34;); } if(!isset($_GET[\u0026#39;b\u0026#39;])){ die(\u0026#34;error2\u0026#34;); } if(!isset($_GET[\u0026#39;c\u0026#39;])){ die(\u0026#34;error2\u0026#34;); } if ($_GET[\u0026#39;b\u0026#39;] == $_GET[\u0026#39;c\u0026#39;]){ die(\u0026#34;error2\u0026#34;); } if (md5($_GET[\u0026#39;b\u0026#39;]) !== md5($_GET[\u0026#39;c\u0026#39;])){ die(\u0026#34;error2\u0026#34;); } if(!isset($_GET[\u0026#39;d_1.01\u0026#39;])){ die(\u0026#34;error3\u0026#34;); } if(!isset($_GET[\u0026#39;flag\u0026#39;])){ die(\u0026#34;error4\u0026#34;); } if(!isset($_POST[\u0026#39;flag\u0026#39;])){ die(\u0026#34;error4\u0026#34;); } foreach($_GET as $key =\u0026gt; $value){ $$key = $$value; } class test{ public $a=\u0026#39;123\u0026#39;; public function __wakeup(){ $this-\u0026gt;a=\u0026#39;123\u0026#39;; } public function __destruct(){ if($this-\u0026gt;a !== \u0026#39;abc\u0026#39;){ die(\u0026#34;error5\u0026#34;); } echo $GLOBALS[\u0026#39;fake_flag\u0026#39;]; } } if(!isset($_GET[\u0026#39;obj\u0026#39;])){ die(\u0026#34;error4\u0026#34;); } unserialize($_GET[\u0026#39;obj\u0026#39;]); 题解 一句话总结：利用各类“绕过”\npreg_match(\u0026quot;/[0-9]/\u0026quot;, $num),当num是数组时会返回false，也可以直接不传入a的值 md5()数组绕过，返回值都是null 在firefox中用hackbar，可以方便地写post等的数据 d_1.01的“.”是非法字符，但是把“_”换成“[” ，可以绕过，原理是第一个非法字符被变成了“_”,其余的非法字符得以保留 foreach()语句中的操作被称为“变量覆盖”，可以利用它把fake_flag中的值覆盖为真flag的值，因为代码最终只输出了fake_flag 综上，可以写成如下形式：\nhttp://webt4.chall.ctf.l3hsec.com/?a\u0026amp;b[]\u0026amp;c[]=1\u0026amp;d[1.01\u0026amp;fake_flag=flag\u0026amp;obj=O:4:\u0026#34;test\u0026#34;:2:{s:1:\u0026#34;a\u0026#34;;s:3:\u0026#34;abc\u0026#34;}\u0026amp;flag\u0026amp;$_post[\u0026#39;flag\u0026#39;] Reverse pyencode 题目 encode\n9 0 BUILD_LIST 0 2 STORE_FAST 1 (ret) 10 4 LOAD_GLOBAL 0 (list) 6 LOAD_FAST 0 (s) 8 CALL_FUNCTION 1 10 STORE_FAST 2 (ls) 11 12 LOAD_GLOBAL 1 (range) 14 LOAD_CONST 1 (0) 16 LOAD_GLOBAL 2 (len) 18 LOAD_FAST 2 (ls) 20 CALL_FUNCTION 1 22 LOAD_CONST 2 (2) 24 CALL_FUNCTION 3 26 GET_ITER \u0026gt;\u0026gt; 28 FOR_ITER 90 (to 120) 30 STORE_FAST 3 (i) 12 32 LOAD_GLOBAL 3 (ord) 34 LOAD_FAST 2 (ls) 36 LOAD_FAST 3 (i) 38 BINARY_SUBSCR 40 CALL_FUNCTION 1 42 STORE_FAST 4 (num1) 13 44 LOAD_GLOBAL 3 (ord) 46 LOAD_FAST 2 (ls) 48 LOAD_FAST 3 (i) 50 LOAD_CONST 3 (1) 52 BINARY_ADD 54 BINARY_SUBSCR 56 CALL_FUNCTION 1 58 STORE_FAST 5 (num2) 14 60 LOAD_FAST 4 (num1) 62 LOAD_CONST 4 (248) 64 BINARY_AND 66 LOAD_CONST 5 (3) 68 BINARY_RSHIFT 70 STORE_FAST 6 (numa) 15 72 LOAD_FAST 4 (num1) 74 LOAD_CONST 6 (7) 76 BINARY_AND 78 LOAD_CONST 5 (3) 80 BINARY_LSHIFT 82 LOAD_FAST 5 (num2) 84 LOAD_CONST 7 (240) 86 BINARY_AND 88 LOAD_CONST 8 (4) 90 BINARY_RSHIFT 92 BINARY_OR 94 STORE_FAST 7 (numb) 16 96 LOAD_FAST 5 (num2) 98 LOAD_CONST 9 (15) 100 BINARY_AND 102 STORE_FAST 8 (numc) 17 104 LOAD_FAST 1 (ret) 106 LOAD_FAST 6 (numa) 108 LOAD_FAST 7 (numb) 110 LOAD_FAST 8 (numc) 112 BUILD_LIST 3 114 BINARY_ADD 116 STORE_FAST 1 (ret) 118 JUMP_ABSOLUTE 28 18 \u0026gt;\u0026gt; 120 LOAD_FAST 1 (ret) 122 RETURN_VALUE None output\n[13, 35, 3, 13, 7, 3, 12, 46, 3, 15, 30, 1, 6, 19, 9, 6, 62, 6, 7, 3, 6, 12, 34, 13, 12, 51, 1, 12, 11, 6, 5, 43, 4, 12, 11, 3, 6, 50, 13, 7, 14, 6, 6, 6, 6, 5, 43, 3, 6, 43, 8, 6, 59, 3, 12, 35, 3, 12, 11, 1, 6, 46, 6, 6, 15, 13] 题解 encode是python字节码,用 python -m dis xxx.py 可以查看字节码 经过分析，对应的代码如下：\nret = [] ls = list(s) for i in range(0, len(s), 2): num1 = ord(ls[i]) num2 = ord(ls[i + 1]) numa = (num1 \u0026amp; 248) \u0026gt;\u0026gt; 3 numb = ((num1 \u0026amp; 7) \u0026gt;\u0026gt; 3) | ((num2 \u0026amp; 240) \u0026gt;\u0026gt; 4) numc = num2 + 15 ret = ret + [numa, numb, numc] 注意：\n字节码中and和add不要看错（大哭） 因为有很多按位与的操作，所以很难反推出flag，只能正向尝试。 这段代码相当于是把两个数字经过某个函数变成了三个数字，也就是说串s可以每两个分为一组，组间互不干扰，所以正向遍历所有情况计算量也很小 得到flag的代码如下图：\n一些未完待续 Pwn-ret2text 查资料得“ret2text”是栈溢出实例。\n在kali中安装pwndbg，pwntools等 直接在文件所在的位置处打开终端 file ret2text查看基本信息 使用checksec工具查看它开了什么保护措施，网上很多命令为： checksec ret2text,我的会报错Error: No option selected. Please select an option.后来查到可能是版本问题,最后写成checksec --file=ret2text 用IDA打开文件，按f5反汇编，得到如下信息:\nmian函数 看到提示：positive sp value has been detected, the output may be wrong! 找到与flag有关的函数 read_flag函数从00000000004007D8开始 gdb调试\ngdb ret2text打开调试 b main在main函数设置断点 r运行，一开始显示错误，经过搜索是因为对文件的权限不够，用chmod u+x ret2text提升权限 在main函数输入v4的时候输入一个字符串 关注0x7fffffffde40和0x7fffffffdef8两行，相减得148 5.写代码如下：\nfrom pwn import * from wstube import websocket p = websocket(\u0026#39;ws://ret2sc.websocket.chall.ctf.l3hsec.com\u0026#39;) payload = b\u0026#39;a\u0026#39; * 184 +p64(0x4007d8) p.sendline(payload) p.interactive() 出现Got EOF while reading in interactive 没有成功，目前还不知道原因。\n写在最后 在查资料的过程中看到很多相关知识，比如常用的文件头有哪些、绕过MD5的多种方式，rsa的其他题型、misc用到了哪些工具、有哪些好用的在线网站等等。已经保存了可是太凌乱了。。。最近忙到起飞呜呜呜，有时间再分专题整理\n","date":"2023-10-11T07:58:34+08:00","permalink":"https://blog.nrevery.cn/p/ctf%E6%88%98%E9%98%9F%E6%8B%9B%E6%96%B0%E8%B5%9B/","title":"CTF战队招新赛"}]
[{"content":"CTF战队招新 Misc Signin 略\nbase64? 题目 我的密文: ox6qJI1Q7kJY1OvuR/1CBs1yRVvuEIfeR/lCUMAGrV8LwEL= 泄露的明文: jRQfVJMwco5wegcVY3cAFi5a7V97IIWMgNh/epeit8Prp1+vdved0CzndIyCqfEMvho3YF33SYjeif4oi0mGscBFhRH70i17E8IgGAVXtZGDhSK9vPkH5MhI 泄露的密文: N+d9r+rjVElQoG1krPlQ1+MG8LvXNV1p658u6L+d1L5aVsFKrEA+NEUhB/dYRTfIr/r+rxAx7suMTE+xJPrvVErqoG6r9QRGB5+0rP+s6XSWRX5/JI6m9spTTxJYNVnk9VpdrLlA1+pLPMlnNv6zbErUNLF5VPpd 你现在知道我的明文了吗？ 题解 将泄露的明文用base64加密 alJRZlZKTXdjbzV3ZWdjVlkzY0FGaTVhN1Y5N0lJV01nTmgvZXBlaXQ4UHJwMSt2ZHZlZDBDem5kSXlDcWZFTXZobzNZRjMzU1lqZWlmNG9pMG1Hc2NCRmhSSDcwaTE3RThJZ0dBVlh0WkdEaFNLOXZQa0g1TWhJ 发现泄露的密文与加密后的密文的字符有对应关系 （代码不小心删了，就是找到目前能对应的字符并且把我的密文尽量转换，并且输出目前还没有对应的字符） 将得到的不完整的明文每四个字符进行base64解密，得到flag的大部分。根据推理和几次尝试就得到完整的flag（ Robot36 题目 给了一个png文件和一个flac文件\n题解 用winhex打开cover.png，最下面有提示 用winhex打开flac文件找到wav的文件头并删除之前的内容,并转换为wav文件 用安卓手机下载Robot36，用另一个设备播放即可得到慢扫描图像 CTYPTO factor 题目 from Crypto.Util.number import * flag = b\u0026#39;*****\u0026#39; p = getPrime(512) q = getPrime(512) n = p*q e = 0x10001 m = bytes_to_long(flag) c = pow(m,e,n) # print(p) # print(q) print(n) print(c) #n = 155973472877500551696404049342507495077134952416313340244284845928778400385389548636037403472336378336490931666382159990607516752340206514340009510417187026921007116552045963973163720919596636575029141772459275706505175142195195686881713118383919643653234410908740422880120161538592336383479253864155940629093 #c = 32349988441710439726991823014652327949110727303493414402820119679942533399117470462729126720315109509283386087378965374529410971247867614623318967344071216979994926505735379297102144644819487720051553195643392945426400493308569024431403247836671630208580022421678378308476007451938426212992790979191141986943 题解 这是已知n、c的rsa加密题\nRSA加密算法用到六个数字，p,q,n,φ(n),e,d,主要过程如下：\n随意选择两个大的质数$p$和$q$，$p$不等于$q$，计算$n=pq$。 根据欧拉函数，不大于N且与N互质的整数個数為$φ(n)=(p-1)(q-1)$。 选择一个整数e与φ(n)互质，并且e小于φ(n)。 用以下这个公式计算$d：d×e ≡ 1 (mod φ(n))$。 将p和q的记录销毁。 具体过程：\n在RSATool中把n填入对应位置点Factor N,将n分解为两个素数，即p,q。 再点Calc.D得到d,此时可以点Test，输入一个数字，先加密再解密，若数字不变则测试成功，把密文c输入并解密即可得到flag 以上所有操作都可以在python中解决，且题型可以是知道6个数字中的其他一些数字，根据情况处理即可。 Web phpplayer 题目 \u0026lt;?php highlight_file(__FILE__); $flag=file_get_contents(\u0026#34;/flag\u0026#34;); $fake_flag=\u0026#34;flag{xxxxxxxxxxxxxxxxx}\u0026#34;; if(!isset($_GET[\u0026#39;a\u0026#39;])){ die(\u0026#34;error1\u0026#34;); } $num = $_GET[\u0026#39;a\u0026#39;]; if(preg_match(\u0026#34;/[0-9]/\u0026#34;, $num)){ die(\u0026#34;error1\u0026#34;); } if(!intval($num)){ die(\u0026#34;error1\u0026#34;); } if(!isset($_GET[\u0026#39;b\u0026#39;])){ die(\u0026#34;error2\u0026#34;); } if(!isset($_GET[\u0026#39;c\u0026#39;])){ die(\u0026#34;error2\u0026#34;); } if ($_GET[\u0026#39;b\u0026#39;] == $_GET[\u0026#39;c\u0026#39;]){ die(\u0026#34;error2\u0026#34;); } if (md5($_GET[\u0026#39;b\u0026#39;]) !== md5($_GET[\u0026#39;c\u0026#39;])){ die(\u0026#34;error2\u0026#34;); } if(!isset($_GET[\u0026#39;d_1.01\u0026#39;])){ die(\u0026#34;error3\u0026#34;); } if(!isset($_GET[\u0026#39;flag\u0026#39;])){ die(\u0026#34;error4\u0026#34;); } if(!isset($_POST[\u0026#39;flag\u0026#39;])){ die(\u0026#34;error4\u0026#34;); } foreach($_GET as $key =\u0026gt; $value){ $$key = $$value; } class test{ public $a=\u0026#39;123\u0026#39;; public function __wakeup(){ $this-\u0026gt;a=\u0026#39;123\u0026#39;; } public function __destruct(){ if($this-\u0026gt;a !== \u0026#39;abc\u0026#39;){ die(\u0026#34;error5\u0026#34;); } echo $GLOBALS[\u0026#39;fake_flag\u0026#39;]; } } if(!isset($_GET[\u0026#39;obj\u0026#39;])){ die(\u0026#34;error4\u0026#34;); } unserialize($_GET[\u0026#39;obj\u0026#39;]); 题解 一句话总结：利用各类“绕过”\npreg_match(\u0026quot;/[0-9]/\u0026quot;, $num),当num是数组时会返回false，也可以直接不传入a的值 md5()数组绕过，返回值都是null 在firefox中用hackbar，可以方便地写post等的数据 d_1.01的“.”是非法字符，但是把“_”换成“[” ，可以绕过，原理是第一个非法字符被变成了“_”,其余的非法字符得以保留 foreach()语句中的操作被称为“变量覆盖”，可以利用它把fake_flag中的值覆盖为真flag的值，因为代码最终只输出了fake_flag 综上，可以写成如下形式：\nhttp://webt4.chall.ctf.l3hsec.com/?a\u0026amp;b[]\u0026amp;c[]=1\u0026amp;d[1.01\u0026amp;fake_flag=flag\u0026amp;obj=O:4:\u0026#34;test\u0026#34;:2:{s:1:\u0026#34;a\u0026#34;;s:3:\u0026#34;abc\u0026#34;}\u0026amp;flag\u0026amp;$_post[\u0026#39;flag\u0026#39;] Reverse 题目 encode\n9 0 BUILD_LIST 0 2 STORE_FAST 1 (ret) 10 4 LOAD_GLOBAL 0 (list) 6 LOAD_FAST 0 (s) 8 CALL_FUNCTION 1 10 STORE_FAST 2 (ls) 11 12 LOAD_GLOBAL 1 (range) 14 LOAD_CONST 1 (0) 16 LOAD_GLOBAL 2 (len) 18 LOAD_FAST 2 (ls) 20 CALL_FUNCTION 1 22 LOAD_CONST 2 (2) 24 CALL_FUNCTION 3 26 GET_ITER \u0026gt;\u0026gt; 28 FOR_ITER 90 (to 120) 30 STORE_FAST 3 (i) 12 32 LOAD_GLOBAL 3 (ord) 34 LOAD_FAST 2 (ls) 36 LOAD_FAST 3 (i) 38 BINARY_SUBSCR 40 CALL_FUNCTION 1 42 STORE_FAST 4 (num1) 13 44 LOAD_GLOBAL 3 (ord) 46 LOAD_FAST 2 (ls) 48 LOAD_FAST 3 (i) 50 LOAD_CONST 3 (1) 52 BINARY_ADD 54 BINARY_SUBSCR 56 CALL_FUNCTION 1 58 STORE_FAST 5 (num2) 14 60 LOAD_FAST 4 (num1) 62 LOAD_CONST 4 (248) 64 BINARY_AND 66 LOAD_CONST 5 (3) 68 BINARY_RSHIFT 70 STORE_FAST 6 (numa) 15 72 LOAD_FAST 4 (num1) 74 LOAD_CONST 6 (7) 76 BINARY_AND 78 LOAD_CONST 5 (3) 80 BINARY_LSHIFT 82 LOAD_FAST 5 (num2) 84 LOAD_CONST 7 (240) 86 BINARY_AND 88 LOAD_CONST 8 (4) 90 BINARY_RSHIFT 92 BINARY_OR 94 STORE_FAST 7 (numb) 16 96 LOAD_FAST 5 (num2) 98 LOAD_CONST 9 (15) 100 BINARY_AND 102 STORE_FAST 8 (numc) 17 104 LOAD_FAST 1 (ret) 106 LOAD_FAST 6 (numa) 108 LOAD_FAST 7 (numb) 110 LOAD_FAST 8 (numc) 112 BUILD_LIST 3 114 BINARY_ADD 116 STORE_FAST 1 (ret) 118 JUMP_ABSOLUTE 28 18 \u0026gt;\u0026gt; 120 LOAD_FAST 1 (ret) 122 RETURN_VALUE None output\n[13, 35, 3, 13, 7, 3, 12, 46, 3, 15, 30, 1, 6, 19, 9, 6, 62, 6, 7, 3, 6, 12, 34, 13, 12, 51, 1, 12, 11, 6, 5, 43, 4, 12, 11, 3, 6, 50, 13, 7, 14, 6, 6, 6, 6, 5, 43, 3, 6, 43, 8, 6, 59, 3, 12, 35, 3, 12, 11, 1, 6, 46, 6, 6, 15, 13] 题解 encode是python字节码,用 python -m dis xxx.py 可以查看字节码 经过分析，对应的代码如下：\nret = [] ls = list(s) for i in range(0, len(s), 2): num1 = ord(ls[i]) num2 = ord(ls[i + 1]) numa = (num1 \u0026amp; 248) \u0026gt;\u0026gt; 3 numb = ((num1 \u0026amp; 7) \u0026gt;\u0026gt; 3) | ((num2 \u0026amp; 240) \u0026gt;\u0026gt; 4) numc = num2 + 15 ret = ret + [numa, numb, numc] 注意：\n字节码中and和add不要看错（大哭） 因为有很多按位与的操作，所以很难反推出flag，只能正向尝试。 这段代码相当于是把两个数字经过某个函数变成了三个数字，也就是说串s可以每两个分为一组，组间互不干扰，所以正向遍历所有可能也计算量很小 得到flag的代码如下图：\n","date":"2023-10-11T07:58:34+08:00","permalink":"https://blog.nrevery.cn/p/ctf%E6%88%98%E9%98%9F%E6%8B%9B%E6%96%B0/","title":"CTF战队招新"}]